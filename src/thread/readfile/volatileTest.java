package thread.readfile;
/**
 *@auth wws
 *@date 2018年3月28日---上午11:48:20
 *volatile的语义：
  *1、保证被volatile修饰的变量对所有其他的线程的可见性。
  *2、使用volatile修饰的变量禁止指令重排优化。
 *Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，
  *而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。
 *java语言规范指出：为了获取最佳的运行速度，允许线程保留共享变量的副本，当这个线程进入或者离开同步代码块时，
  *才与共享成员变量进行比对，如果有变化再更新共享成员变量。这样当多个线程同时访问一个共享变量时，可能会存在值不同步的现象。
  *而volatile这个值的作用就是告诉VM：对于这个成员变量不能保存它的副本，要直接与共享成员变量交互。
  *建议：当多个线程同时访问一个共享变量时，可以使用volatile，而当访问的变量已在synchronized代码块中时，不必使用。
  *缺点：使用volatile将使得VM优化失去作用，导致效率较低，所以要在必要的时候使用。
  *
  *原子性，根据我个人的理解：当前变量只允许一个线程来操作，不接受多线程来访问。所以每次的都是最新的值。
  *可见性，根据我个人的理解：变量t。A线程对t变量修改的值，对B线程是可见的。但是A获取到t的值加1之后，突然挂起了，
 *B获取到的值还是最新的值，volatile能保证B能获取到的t是最新的值，因为A的t+1并没有写到主内存里面去。这个逻辑是没有问题的。
 **/
public class volatileTest {

}
